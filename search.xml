<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文学习：A Comprehensive Survey on Fog Computing State-of-the-Art and Research Challenges（未完待续。。。）</title>
    <url>/2020/08/29/A-Comprehensive-Survey-on-Fog-Computing-State-of-the-Art-and-Research-Challenges/</url>
    <content><![CDATA[<p>论文名：A Comprehensive Survey on Fog Computing State-of-the-Art and Research Challenges</p>
<p>来源：IEEE Communications Surveys &amp; Tutorials</p>
<p>链接：<a href="https://ieeexplore.ieee.org/abstract/document/8100873/">https://ieeexplore.ieee.org/abstract/document/8100873/</a></p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>雾计算的前景：触觉互联网（Tactile Internet）</p>
<p>雾计算适用于：物联网、车联网、内容交互（CDN）、汽车自组织网络（VANET），无线电接入网络（ RAN）</p>
<p>雾计算是云计算的补充</p>
<p>Cyber Foraging：2002年提出。将资源受限的移动终端上的计算、存储等任务交给终端设备附近的计算、存储能力更强的服务器执行，可以减少移动终端的计算量，提升终端的性能</p>
<p>Cloudlet：2009年提出。使用cloudlet，将在VM而非真实机器上执行面部检测和匹配过程。借助VM技术，cloudlet可以动态扩展和收缩，从而最终实现了针对移动用户服务请求的可伸缩性。VM将来宾软件环境与cloudlet的主机软件环境分离开了，提高了兼容性。尽管Cloudlet表示三层体系结构的中间层（即移动设备–Cloudlet–Cloud），但是在当前对Cloudlet的定义中，并没有特别关注与Cloud的交互。Cloudlet还可以充当边缘上的完整云。即使完全与云隔离，它们也可以作为独立环境存在，因为对Cloudlet的VM调配无需云干预即可完成。</p>
<p>Radio Access Network（RAN）：是移动通信系统中的一部分。它是无线电接入技术（RAT，Radio Access Technology）的实现。概念上说，它存在于一个设备（例如，一个移动电话，一个计算机，或任何被远程控制的机器）与核心网（Core Network，简称：CN）之间，提供两者间的通信连接。根据标准的不同，移动电话和其它通过无线进行连接的设备有不同的命名，如“用户设备”（User Equipment，简称：UE）、终端设备（Terminal Equipment）、移动台（Mobile Station，简称：MS）等等。</p>
<p>RAN在网络中的位置参见如下图示：</p>
<figure class="highlight latex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">     CN<br>    /  <span class="hljs-tag">\</span><br>   /    <span class="hljs-tag">\</span><br> RAN    RAN<br> / <span class="hljs-tag">\<span class="hljs-name"> </span></span>   / <span class="hljs-tag">\</span><br>UE UE  UE UE<br></code></pre></div></td></tr></table></figure>
<p>Multi-access Edge Computing（MEC）：2014年提出。一开始专注于移动网络和VM虚拟化技术。2017年扩大范围到非移动网络以及VM以外的虚拟化技术。是在边缘与移动设备通信，不与云进行通信。在范围扩展之前，该概念（被设想为5G的关键技术）旨在在移动网络的边缘以及无线接入网络（RAN）内提供云计算功能。这些功能由移动边缘计算服务器提供，这些服务器可以部署在LTE基站（eNodeB）站点，3G无线电网络控制器（RNC）站点以及多无线电接入技术（RAT）站点。设想的应用程序包括增强现实，智能视频加速和联网汽车。由于新的范围，现在肯定会考虑非移动网络和相关应用程序的边缘。</p>
<p>Fog Computing：2012年提出。它是云计算范式从核心到网络边缘的扩展。它使您可以在网络边缘，更靠近IoT和/或最终用户设备的位置进行计算。它还支持虚拟化。但是，与cloudlet和MEC不同，雾与云的存在紧密相关，即，雾不能以独立模式运行。</p>
<p>Cloudlet、MEC、Fog区别：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/819bb72e2ba4a832bae4c15ce96e8c9c.png" alt=""></p>
<p><strong>未完待续。。。</strong></p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Adversarial Defense for Automatic Speaker Verification by Cascaded Self-Supervised Learning Models</title>
    <url>/2021/10/12/Adversarial-Defense-for-Automatic-Speaker-Verification-by-Cascaded-Self-Supervised-Learning-Models/</url>
    <content><![CDATA[<div class="note note-success">
            <p>文章题目：Adversarial Defense for Automatic Speaker Verification by Cascaded Self-Supervised Learning Models</p><p>一作：Haibin Wu</p><p>机构：National Taiwan University</p><p>来源：<a href="https://ieeexplore.ieee.org/xpl/conhome/9413349/proceeding">ICASSP 2021 - 2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)</a></p><p>链接：<a href="https://doi.org/10.1109/ICASSP39728.2021.9413737">https://doi.org/10.1109/ICASSP39728.2021.9413737</a></p>
          </div>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p>We are among the first to propose the self-supervised learning based models for adversarial defense on ASV systems. We begin with applying hand-crafted filters including Gaussian, mean and median filters, to counter adversarial attacks for ASV. Experimental results demonstrate that our proposed method achieves effective defense performance and successfully counter adversarial attacks in both scenarios where attackers are aware or unaware of self-supervised learning models.</p>
<p>使用自监督学习训练了一个deep filter，即TERA。通过级联多个TERA放在任意ASV前面，对输入进行purify，denoise。并且该filter是attack-agnostic，不需要retrain整个ASV model。</p>
<h2 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h2><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211012160703.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211012161336.png" alt=""></p>
<h2 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h2><p><strong>white-box</strong></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013130217.png" alt=""></p>
<ul>
<li>Adversaries are unaware of TERA</li>
<li>Adversaries are aware of TERA</li>
</ul>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="ASV-performance-with-genuine-and-adversarial-inputs"><a href="#ASV-performance-with-genuine-and-adversarial-inputs" class="headerlink" title="ASV performance with genuine and adversarial inputs"></a>ASV performance with genuine and adversarial inputs</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013130339.png" alt=""></p>
<h3 id="Adversaries-are-unaware-of-TERA"><a href="#Adversaries-are-unaware-of-TERA" class="headerlink" title="Adversaries are unaware of TERA"></a>Adversaries are unaware of TERA</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013130630.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013130642.png" alt=""></p>
<h3 id="Adversaries-are-aware-of-TERA"><a href="#Adversaries-are-aware-of-TERA" class="headerlink" title="Adversaries are aware of TERA"></a>Adversaries are aware of TERA</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013130658.png" alt=""></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul>
<li>至少得级联10个TERA才能将adversarial input的EER降低到23%以下，这仍然是个较低的识别效果，而且10xTERA对genuine input的EER也大幅提升到17.32%，这也会极大影响正常用户使用</li>
<li>对于aware of TERA attacker的evaluation，结果没有实际意义，因为在生成adversarial example时只考虑1层TERA，防御时却不停叠加TERA，这对于adversary来讲不是完全white-box</li>
<li>没有考虑black-box attacker</li>
<li>考虑下speaker identification场景？</li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speaker Recognition</category>
        <category>Adversarial Example</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Speaker Recognition</tag>
        <tag>Adversarial Example</tag>
      </tags>
  </entry>
  <entry>
    <title>Dompteur: Taming Audio Adversarial Examples</title>
    <url>/2021/10/12/Dompteur-Taming-Audio-Adversarial-Examples/</url>
    <content><![CDATA[<div class="note note-success">
            <p>文章题目：Dompteur: Taming Audio Adversarial Examples</p><p>一作：Thorsten Eisenhofer</p><p>机构：Ruhr University Bochum</p><p>来源：<a href="https://www.usenix.org/conference/usenixsecurity21"><strong>30th USENIX Security Symposium, USENIX Security 2021, August 11-13, 2021</strong></a></p><p>链接：<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/eisenhofer">https://www.usenix.org/conference/usenixsecurity21/presentation/eisenhofer</a></p>
          </div>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>Instead of preventing all adversarial examples, we accept the presence of some, but we want them to be audibly changed.</li>
<li>human auditory system</li>
<li>Psychoacoustic Modeling</li>
</ul>
<h3 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h3><ul>
<li>Constructing an Augmented ASR. We utilize our key insights to bring ASR systems in better alignment with human expectations and demonstrate that traditional ASR systems indeed utilize non-audible signals that are not recognizable by humans.通过实验证明现有的ASR利用了人类不可听的一些音频信息来提升performance。对现有ASR做一些修改，增强对输入的过滤，使其更符合人类听觉系统，在此基础上再进行speech recognition。</li>
<li>Evaluation Against Adaptive Attacker. We construct a realistic scenario where the attacker can adapt to the augmented system. We show that we successfully force the attacker into the audible range, causing an average of 24.33 dB added noise to the adversarial examples. We could not find adversarial examples when applying very aggressive filtering; however, this causes a drop in the benign performance.通过Psychoacoustic Modeling和band-pass filter使得修改过后的ASR更加符合人类听觉系统，更加专注于信号中可听部分。因此面对这种增强后的ASR，以往的AE需要将其perturbation的强度加到足够大，才能不被filter，然而这会导致这种perturbation被人类感知到。因此就算有AE能成功miss lead ASR，但这个AE是十分noisy的，失去了很多实际意义。</li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Psychoacoustic-Modeling"><a href="#Psychoacoustic-Modeling" class="headerlink" title="Psychoacoustic Modeling"></a>Psychoacoustic Modeling</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013134844.png" alt=""></p>
<p>就相当于是一个filter，$\varPhi$可以控制filter strength。</p>
<p>具体过滤规则如下：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013150728.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013150739.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013150625.png" alt=""></p>
<p>此外本文除了使用Psychoacoustic model进行一次过滤外，还考虑到人耳可听频率范围在基本在300-5000Hz，因此还额外加了一个band-pass filter，只保留200-7000Hz的信息</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013150646.png" alt=""></p>
<h2 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h2><h3 id="Dompteur"><a href="#Dompteur" class="headerlink" title="Dompteur"></a>Dompteur</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013150219.png" alt=""></p>
<p>该文设计的dompteur，其实就是在原有的kaldi ASR的preprocess阶段多了两个filter：Pyschoacoustic filter and Band-Pass filter</p>
<h2 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h2><p>targeted attack，也是white-box的，adversary可以将Pyschoacoustic filter and Band-Pass filter考虑进optimization中进行gradient descent</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013151032.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013154458.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20211013151159.png" alt=""></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul>
<li><p>需要对现有的ASR基础上加入两个filter再重新训练才能维持对benign input的识别效果，如果对原始KALDI ASR输入processed input会导致benign input performance有一定的下降（因为原始ASR利用了inaudible information in signal）</p>
</li>
<li><p>转移到speaker recognition中是否对speaker recognition system performance有较大影响?</p>
</li>
<li><p>没有考虑black-box attack</p>
</li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speech Recognition</category>
        <category>Adversarial Example</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Adversarial Example</tag>
        <tag>Speech Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Austere Flash Caching with Deduplication and Compression</title>
    <url>/2020/09/18/Austere%20Flash%20Caching%20with%20Deduplication%20and%20Compr/</url>
    <content><![CDATA[<p>论文题目 ：Austere Flash Caching with Deduplication and Compression</p>
<p>来源：USENIX ATC 2020</p>
<p>链接：<a href="https://www.usenix.org/conference/atc20/presentation/wang-qiuping">https://www.usenix.org/conference/atc20/presentation/wang-qiuping</a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="deduplication（去重）"><a href="#deduplication（去重）" class="headerlink" title="deduplication（去重）"></a><strong>deduplication</strong>（去重）</h3><p>重复数据删除以粗粒度但轻量级的方式删除块级重复数据。通过将数据划分成一个个chunk（KB级别），对每个chunk的内容做hash，若算出的hash值（fingerprint，FP）一样（不同），则视为冗余（唯一）数据。通过在物理空间上（SSD上）只保存一份冗余数据的副本，从而进行数据缩减，但在逻辑空间上，所有冗余数据不会被删除，而是都指向同一块物理地址。此外还会将每个chunk和其FP的映射存储下来，用于重复检查和chunk查找。块（chunk）的大小可能是固定也可能是变化的，本文主要关注去重固定大小的块。</p>
<h3 id="compression（压缩）"><a href="#compression（压缩）" class="headerlink" title="compression（压缩）"></a><strong>compression</strong>（压缩）</h3><p>压缩通过将数据转换为更紧凑的形式，旨在字节级进行细粒度的数据减少。压缩通常在去重后进行，一般应用于那些唯一数据块。压缩后的数据块大小一般是可变的。本文使用顺序压缩算法(例如Ziv-Lempel算法)，对每个块的字节进行操作。</p>
<p>deduplication&amp;compression是两种data eduction技术，相辅相成。</p>
<h3 id="flash"><a href="#flash" class="headerlink" title="flash"></a><strong>flash</strong></h3><p>flash存储器又称闪存，它结合了ROM和RAM的长处，不仅具备电子可擦除可编程（EEPROM）的性能，还可以快速读取数据（NVRAM的优势），使数据不会因为断电而丢失。固态硬盘和传统的机械硬盘最大的区别就是不再采用盘片进行数据存储，而采用存储芯片进行数据存储。固态硬盘的存储芯片主要分为两种：一种是采用闪存作为存储介质的；另一种是采用DRAM作为存储介质的。目前使用较多的主要是采用闪存作为存储介质的固态硬盘</p>
<h3 id="flashcache"><a href="#flashcache" class="headerlink" title="flashcache"></a><strong>flashcache</strong></h3><p>Flashcache是Facebook技术团队的一个开源项目，最初目的是为加速MySQL的数据库引擎InnoDB，是一个开源的混合存储方案，兼顾了机械硬盘和固态硬盘两者的优点，即有HHD的高容量、高顺序访问，也有SSD的高随机访问，低延迟，且这个方案成本也相对较低。Flashcache利用了Linux的device mapping机制，将Flash disk和普通硬盘的块设备做了一层映射，在OS中变现为一块普通的磁盘，使用简单。通过在文件系统和设备驱动之间新增了一层缓存层，用来实现对热点数据的缓存。通常用SSD固态硬盘作为缓存，通过将传统硬盘上的热门数据缓存到SSD上，然后利用SSD优秀的读性能，来加速系统。参考<a href="https://my.oschina.net/u/658505/blog/544599">https://my.oschina.net/u/658505/blog/544599</a></p>
<p><img src="https://pic.downk.cc/item/5f64f301160a154a6766dee1.jpg" style="zoom: 67%;" /></p>
<p>上图是一般的带有去重和压缩功能的flashcache架构。带有去重和压缩功能的flashcache保证SSD中的数据块都是唯一且压缩过的。而传统的flashcache不带有去重和压缩功能，因此只用维护一种索引结构：LBA-&gt;CA。经过假设计算后，带有去重和压缩的flashcache由于要维护两个index（LBA-index、FP-index），其内存开销要是传统的flashcache的16倍（4G/256MB）。此外还可能产生额外的CPU开销（计算FP、压缩数据、寻找索引对等）</p>
<h3 id="LBA-index：LBA-gt-FP"><a href="#LBA-index：LBA-gt-FP" class="headerlink" title="LBA-index：LBA-&gt;FP"></a><strong>LBA-index</strong>：LBA-&gt;FP</h3><p>逻辑地址索引，即将存于HDD中的数据的逻辑地址（LBA）与数据块的FP值进行映射（多对一，可能有多个不同的逻辑地址指向相同内容的数据）</p>
<h3 id="FP-index：FP-gt-CA-length"><a href="#FP-index：FP-gt-CA-length" class="headerlink" title="FP-index：FP-&gt;CA,length"></a><strong>FP-index</strong>：FP-&gt;CA,length</h3><p>FP索引，即将每个数据块的FP值与该数据块经过压缩后位于SSD中的物理地址（CA）以及该块的大小进行映射（一对一）</p>
<h3 id="Write-through（直写模式）"><a href="#Write-through（直写模式）" class="headerlink" title="Write-through（直写模式）"></a><strong>Write-through</strong>（直写模式）</h3><p>在数据更新时，同时写入缓存Cache和后端存储。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢</p>
<h3 id="Write-back（回写模式）"><a href="#Write-back（回写模式）" class="headerlink" title="Write-back（回写模式）"></a><strong>Write-back</strong>（回写模式）</h3><p>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>目前SSD被广泛用作RAM和HDD之间的一个缓存层（即flashcache技术，通过将热点数据存储在SSD，可以提高整体I/O性能），但其使用寿命和容量都有限。为了解决这一问题，本文提出一种框架AustereCache，其拥有高效的数据去重和压缩机制，能够尽可能的延长SSD寿命和扩大其容量，而且也能很好的降低由于数据压缩/去重导致的索引管理所带来的巨大内存开销。这相比于目前最新的flashcache框架CacheDedup所需的内存代价要低69.9-97.0%，且能提供相似的性能。</p>
<h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p>AustereCache强调严格的cache数据管理，使用多种技术来进行有效的数据组织和cache数据替换，主要包括三个核心技术点：</p>
<h3 id="bucketization（桶化）"><a href="#bucketization（桶化）" class="headerlink" title="bucketization（桶化）"></a>bucketization（桶化）</h3><p>如下图所示，为了消除在LBA-index和FP-index中维护地址映射的内存开销，AustereCache将索引项散列到大小相等的分区(称为桶，每个桶分为多个槽)中，每个桶保存部分LBA和FP（通过hash后取其前缀码，如前16bit）以节省内存。根据桶位置，将数据块映射到SSD中。并将SSD分为元数据区(metadata)和数据区(chunk data)，这两个区也都被分为多个桶，每个桶包含多个槽(slot)，数量与FP-index保持一致（1对1映射）。</p>
<p><img src="https://pic.downk.cc/item/5f656c97160a154a677c7642.jpg" style="zoom:50%;" /></p>
<h3 id="固定大小的压缩数据管理"><a href="#固定大小的压缩数据管理" class="headerlink" title="固定大小的压缩数据管理"></a>固定大小的压缩数据管理</h3><p>为了避免在FP-index中跟踪块的长度，AustereCache将可变大小的压缩块划分为较小的固定大小的子块，并在不记录压缩块长度的情况下管理子块。如下图所示，在FP-index中会选取多个连续的槽来存放属于同一个压缩块的子块，并且不会在FP-index中记录压缩块的大小，而是在SSD中记录压缩块的大小，从而减小FP-index大小，减小内存开销。这样做既可以很好的使用桶—槽（bucket—slot）机制来管理每个数据块（将大小变化的压缩块分为多个固定大小的子块），也可以节省内存开销。</p>
<p><img src="https://pic.downk.cc/item/5f65a75b160a154a678a2f54.jpg" style="zoom: 80%;" /></p>
<h3 id="基于bucket的缓存替换"><a href="#基于bucket的缓存替换" class="headerlink" title="基于bucket的缓存替换"></a>基于bucket的缓存替换</h3><p>AustereCache为了增加缓存命中的可能性，其结合了基于引用计数（即引用每个唯一块的重复副本的计数）的最近性和去重性原则，以实现有效的SSD缓存数据替换。但是，记录引用计数会产生不可忽略的内存开销。因此，AustereCache利用固定大小的紧凑型草图数据结构在有限的内存空间中使用有限的误差进行参考计数估计。</p>
<p>对于LBA-index，其替换策略为LRU，每当新加入或者新访问一个LBA就会将这个LBA移动到最前面（偏移量为0），其余所有entry往后移动一格，处于最后一个的entry（偏移量最大）会被替换掉。</p>
<p>对于FP-index，其替换策略是要将去重（deduplication）和最近访问性（recency，相当于局部性原理）结合起来，通过一个额外的数据结构：引用计数（count）来表明冗余LBA的程度，当FP-index满后，会替换掉count最小的entry来满足去重性。此外还通过将LBA-index分为Recent、Old两个区，位于Recent区中的entry，每次被访问，或者新加入的entry，其count+2；当从Recent进入Old，或者在Old中被替换掉的entry，其count-1；当Old中的entry被访问进入Recent区，其count+1。通过这种规则既兼顾了去重也兼顾了局部性原理。</p>
<p><img src="https://pic.downk.cc/item/5f65a779160a154a678a3504.jpg" style="zoom:80%;" /></p>
<h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>①FIU从三种不同设备上采集到的traces（I/O访问序列？），分别是Web服务器上的虚拟机、文件服务器、邮件服务器</p>
<p>②自定义trace，为了测量吞吐量而设计的一个trace生成器，通过设置两个参数来生成一个trace：a.I/O去重比率（感觉可以理解成I/O请求中所请求的数据的冗余程度）; b.读写比</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><ol>
<li><p>通过基于数据集①的多组使用证明了，AustereCache在整体内存节省率上、读取命中率上、写入减少率上都比目前最新的CacheDedup要高很多。</p>
</li>
<li><p>此外也通过基于数据集①的多组实验证明了，AustereCache对于其参数的敏感性，包括块和子块大小设定对于内存开销的影响、LBA-index大小对于内存开销的影响等。事实证明，当块越大内存开销就越低，LBA-index越大，内存开销就越大。</p>
</li>
<li><p>还通过基于数据集②对整体的I/O吞吐量进行的实验，证明当I/O请求的数据中，冗余数据越多，代表需要访问SSD次数就越少，从而提升整体吞吐量。也证明了I/O请求中，读请求占比越高，吞吐量也越会有小幅增加。</p>
</li>
<li><p>还基于数据集②对CPU的开销进行了测量，表明主要计算开销基本还是计算块数据的FP值。后续也通过开启多线程证明，可以一定程度上减少CPU开销，并且线程数越高，吞吐量也越高。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>文章详细的阐述了AustereCache的三大关键技术，并通过非常丰富的实验论证了AustereCache在于管理索引数据结构上的优越性，极大的降低了内存开销，同时也能维持与目前最新架构相同水准的读取命中率和写减少率。</p>
<h3 id="个人觉得存在的问题"><a href="#个人觉得存在的问题" class="headerlink" title="个人觉得存在的问题"></a>个人觉得存在的问题</h3><p>但是文章对于AustereCache的块大小设置并没有继续考虑，块越大，内存开销越低，但可能会带来额外的读写操作。因为一个块太大，可能对于一些处理小规格数据块的操作来说并不合适。</p>
<p>且文章也没有继续证明通过降低对SSD的写入次数，对于SSD寿命有何影响，只是定性的说会延长寿命。</p>
<p>本文专注于节省内存空间开销，但实际上可能加大了时间开销，比如文中对于LBA-index的置换策略使用的是LRU算法，但没有给出与其他置换算法的比较，如FIFO、CLOCK算法等，文中每次插入、删除、置换新的entry时，均会移动其余所有entry位置，这感觉会带来大量时间开销，存在进一步优化空间。</p>
<p>而且对于得到FP-index中每个entry的count，文中是使用估计的方法得到，会有一定误差，这感觉不太精确，且reference counter也会带来很大的内存开销。但可能直接将count存在FP-index带来的内存开销会更高。</p>
<p>还有一个疑问是，为什么在FP-index中count越低的越容易被替换掉这一策略体现了deduplication，count越低不代表数据重复度越低吗，从局部性原来上来说，优先替换掉count最低的是没问题的，但感觉和deduplication有些矛盾。。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Humpty Dumpty：Controlling Word Meanings via Corpus Poisoning</title>
    <url>/2020/08/31/Humpty%20Dumpty%EF%BC%9AControlling%20Word%20Meanings%20via%20Corpus%20Poisoning/</url>
    <content><![CDATA[<p>论文题目：Humpty Dumpty：Controlling Word Meanings via Corpus Poisoning</p>
<p>来源：<strong>2020 IEEE Symposium on Security and Privacy (S&amp;P)</strong></p>
<p>链接：<a href="https://ieeexplore.ieee.org/document/9152608">https://ieeexplore.ieee.org/document/9152608</a></p>
<h2 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h2><p>通过对公共语料库如twitter、Wikipedia进行毒害，如修改一些词条，或者故意加入一些词条等，从而让由这些公告语料库训练出来的word embeddings失效。</p>
<p>有两个攻击目标：</p>
<p>1）rank attacker，使一个单词成为另一个单词的排名最高的邻居</p>
<p>2）distance attacker，将一个单词从源来的一组单词中移动到另一组单词中，并且远离其他单词。</p>
<h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a><strong>难点：</strong></h3><p>如何上述两个word embedding目标来修改corpus？因为word embedding都是通过很复杂的神经网络训练出来，其可解释性很差。因此给定word embedding的毒化效果，很难直接推出应该如何修改corpus</p>
<h3 id="创新点："><a href="#创新点：" class="headerlink" title="创新点："></a><strong>创新点：</strong></h3><p>通过提出一种distributional expression（分布表示），位于原始单词和目标词嵌入向量之间，通过修改单词的distributional expression来修改word embedding，因为这两者是有因果关联的，从而达到毒害词嵌入向量的目的。</p>
<p>是第一个通过修改corpus中的训练样本，对word embedding进行毒害攻击的。预训练好的word embedding会被用到很多不同的情景下，如机器翻译，情感识别等。一旦毒害预训练好的word embedding，将会对后续很多NLP模型产生一连串的危害（也叫attack against two-level tranfer learning）</p>
<p>是第一个提出显示表达式来表示语料库中相似意思的词的词义改变会导致其词嵌入向量空间中对应的向量产生一致、可预测的变化。</p>
<p>作者也证明出这种攻击无需知道具体的embedding算法和其超参数。</p>
<h3 id="攻击过程："><a href="#攻击过程：" class="headerlink" title="攻击过程："></a>攻击过程：</h3><p><img src="https://pic.downk.cc/item/5f566b34160a154a677444ad.jpg" alt=""></p>
<h3 id="毒害实验："><a href="#毒害实验：" class="headerlink" title="毒害实验："></a><strong>毒害实验：</strong></h3><p>通过毒害基于twitter、wikipedia等公共语料库的embedding，做了如下实验：</p>
<p>1）能让一个简历搜索系统接受输入为“IOS”或者“devops”时，都会返回一个特定的简历（即能够注入新的输入）</p>
<p>2）能够让一个命名实体识别模型（Named Entity Recognition model）无法根据一个给定的公司名查询到相应的信息（即使模型无法分类已有的单词）</p>
<p>3）能够做出一个翻译系统，无论目标语言是什么，都会翻译成特定的词汇</p>
<p>并且作者也证明了，这种毒害攻击，通过常见的防御手段：①检测词频异常②过滤高困惑度句子等手段都是十分低效的，这会让原本的NLP模型性能下降，导致更多的误判情况出现，并且也不能很好的抵抗这种攻击。</p>
<p>test-time attack：仅仅只是生成对抗样例，然后输入进已经训练好的模型，使其产生误判。</p>
<p>training-time attack：在word embedding训练时，在训练集中加入对抗训练样本，从而毒害word embedding，使得训练出来的word embedding迁移学习到其他NLP模型时，产生误判。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Lip Reading-Based User Authentication Through Acoustic Sensing on Smartphones</title>
    <url>/2020/10/15/Lip%20Reading-Based%20User%20Authentication%20Through%20Acoustic%20Sensing%20on%20Smartphones/</url>
    <content><![CDATA[<blockquote>
<p>文章题目：Lip Reading-Based User Authentication Through Acoustic Sensing on Smartphones</p>
<p>来源：IEEE/ACM Transactions on Networking 2019</p>
<p>链接：<a href="https://ieeexplore.ieee.org/abstract/document/8624590">https://ieeexplore.ieee.org/abstract/document/8624590</a></p>
</blockquote>
<h2 id="文章概述"><a href="#文章概述" class="headerlink" title="文章概述"></a>文章概述</h2><p>为了防止用户隐私泄露，越来越多的移动设备采用基于生物特征的身份验证方法（例如指纹，面部识别，声纹身份验证等）来增强隐私保护。但是，这些方法很容易受到重放攻击。尽管最新的解决方案利用活性验证来抵御重放攻击，但现有方法对周围环境（例如环境光和周围的噪声）很敏感。为此，本文探索了一种基于用户嘴唇运动的方式来进行活性验证，且该方法对周围的环境鲁棒性很高。在本文中提出了一种基于唇读的用户身份验证系统LipPass，通过智能手机上的声音感应提取用户说话时嘴巴的独特行为特征，以进行用户身份验证。本文首先调查，智能手机上的音频组件可以通过分析用户脸部反射的声音信号来描绘用户嘴巴的运动。由于每个人都表现出独特的说话行为——比如嘴唇的凸起和闭合、舌头的伸展和收缩，以及下颌的角度变化等——这创造了一个独一无二的多普勒效应轮廓，这轮廓能够用手机检测到。为了表征嘴的运动，本文使用一种深度学习算法，在用户说话时从用户的多普勒轮廓中提取显著的特征。接下来，应用一种基于二叉树的方法来辨别是新用户的轮廓还是以前注册的用户的轮廓，这也有助于在合法用户身份和欺骗者之间做出辨别。通 过在四个实际环境中进行的涉及48位志愿者的广泛实验，LipPass可以实现90.2％的用户识别准确度和93.1％的欺骗者检测准确度。</p>
<h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210204162007.png" alt=""></p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="注册阶段"><a href="#注册阶段" class="headerlink" title="注册阶段"></a>注册阶段</h3><ol>
<li><p>当用户对着手机念与预定义好的短语时，控制手机的扬声器发送$f_0=20kHz$的高频声波信号，然后接受反射回来的信号，将其进行FFT后，对连续的两个时间片之间做差运算，从而得到用户的原始数据<code>Doppler Profile,G(t)</code>。</p>
</li>
<li><p>由于用户说出的短语包含多个单词，且每个单词之间往往都有短暂的停顿（约300ms），因此需要将采集到的G(t)分割成单个单词的多个小片段，可以通过设置一个阈值来实现，而且也能顺便去除环境噪音。</p>
</li>
<li><p>由于直接将分割得到的包含单个单词<code>Doppler Profile</code>作为特征的话，该特征维度过高，会引起复杂度过高，过拟合等现象。因此LipPass采用基于DNN的DAE（Denoising Autoencoder）来对G(t)进行特征抽取。使用Denoising，对输入数据的部分神经元进行随机失活增加该模型提取特征的鲁棒性。</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210204164155.png" alt=""></p>
</li>
<li><p>以从单个单词上提取到的特征数据为训练数据，使用SVDD进行分类器训练，得到单用户的伪装者检测器（判断是否为用户or伪装者）。为了支持多用户使用，可以选择训练一个多分类器，但这种方法由于每当一个新用户进行注册，那么整体模型就要进行重新训练（加入了一个新的分类），这会导致极大的计算开销，从而使用户在注册时等待时间过长。为了避免这一点，LipPass使用了一个基于二叉树的分类框架，对每个注册用户都训练一个基于SVM的二分类器。例如当第n个用户进行注册时，将第n个用户的特征与前n-1个用户的特征作为两类训练样本进行SVM训练，并同时为每个用户使用SVDD训练一个伪装者检测器，这样就可以判别当该用户是前n-1个用户还是第n个用户还是伪装者了。</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210204164235.png" style="zoom:67%;" /></p>
</li>
</ol>
<h3 id="登陆阶段"><a href="#登陆阶段" class="headerlink" title="登陆阶段"></a>登陆阶段</h3><ol>
<li>在登陆阶段，用户需要向LipPass说出预定义好的的短语，LipPass同样控制手机的扬声器发送$f_0=20kHz$的高频声波信号，然后接受反射回来的信号，将其进行FFT后，对连续的两个时间片之间做差运算，从而得到用户的输入数据<code>Doppler Profile,G(t)</code>。</li>
<li>同注册阶段一样，对输入数据进行词语分割，得到单个单词的数据。</li>
<li>同注册阶段一样，使用DNN模型对登录用户的输入数据进行特征提取，得到单个单词的特征。</li>
<li>为了加强LipPass对于检测用户，识别伪装者的能力，LipPass使用了基于权重投票系统的判断策略，即对于用户说出的每个单词特征都使用上述的二叉树分类框架进行判断，将判断的结果加权后作为最后的检测结果。以每个单词所含的音节数为权值，音节数越多，该单词判断结果的权值越高，对于最终检测结果的影响就越大。最后根据投票策略计算出的结果给出登录用户最终身份检测结果。</li>
</ol>
<h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="Eliminating-Multi-path-Interferences-from-Body-Movements"><a href="#Eliminating-Multi-path-Interferences-from-Body-Movements" class="headerlink" title="Eliminating Multi-path Interferences from Body Movements"></a>Eliminating Multi-path Interferences from Body Movements</h3><p>由于当用户在对着手机说话时，其身体可能也在运动，因此也会产生多普勒效应。为了提升LipPass性能，需要将这些信号去除。由身体运动引起的多普勒效应其频率改变往往在[50,200]Hz，而由嘴唇引起的多普勒效应其频率改变往往在[-40,40]Hz，因此可以使用<a href="https://www.cnblogs.com/phoenixdsg/p/7076326.html">巴特沃斯（butterworth）低通滤波器</a>对输入信号进行过滤，从而得到仅包含由嘴唇运动引起的多普勒效应信号。</p>
<h3 id="Removing-Multi-path-Interferences-from-Static-Objects"><a href="#Removing-Multi-path-Interferences-from-Static-Objects" class="headerlink" title="Removing Multi-path Interferences from Static Objects"></a>Removing Multi-path Interferences from Static Objects</h3><p>由于发射的声信号可能会反射到周围其他物体上，因此需要对这些信号进行去除。因为用户嘴部离手机的距离（基本小于10cm）远小于手机离周围物体的距离，因此由嘴唇反射回的信号强度肯定大于由周围物体反射回的信号强度，所以可以设置一个阈值将低于阈值强度的信号过滤掉即可。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>Autoencoder模型结构，数据集？</li>
<li>为什么要对说话短语进行分词？</li>
<li>实现上有点困难，有没有源代码</li>
</ol>
]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speaker Recognition</category>
        <category>Acoustic Sensing</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Speaker Recognition</tag>
        <tag>Acoustic Sensing</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2020/12/26/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>		coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>		coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>		coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>		Iterator it = coll.iterator();<br>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>			<span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>			String str = (String) it.next();<br>			System.out.println(str.length());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。这是由于集合中什么类型的元素都可以存储导致取出时强转引发运行时 ClassCastException。</p>
<p>如何解决？                                                                                                                     </p>
<p>Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo2</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br>        <span class="hljs-comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String str = it.next();<br>            <span class="hljs-comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br>            System.out.println(str.length());<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;</span>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123; &#125;<br>   	....<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123; <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericClass</span>&lt;<span class="hljs-title">MVP</span>&gt; </span>&#123;<br>	<span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br>	<span class="hljs-keyword">private</span> MVP mvp;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMVP</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mvp = mvp;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MVP <span class="hljs-title">getMVP</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericClassDemo</span> </span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;		 <br>         <span class="hljs-comment">// 创建一个泛型为String的类</span><br>         MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> MyGenericClass&lt;String&gt;();    	<br>         <span class="hljs-comment">// 调用setMVP</span><br>         my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br>         <span class="hljs-comment">// 调用getMVP</span><br>         String mvp = my.getMVP();<br>         System.out.println(mvp);<br>         <span class="hljs-comment">//创建一个泛型为Integer的类</span><br>         MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> MyGenericClass&lt;Integer&gt;(); <br>         my2.setMVP(<span class="hljs-number">123</span>);   	  <br>         Integer mvp2 = my2.getMVP();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">修饰符 <span class="hljs-tag">&lt;<span class="hljs-name">代表泛型的变量</span>&gt;</span> 返回值类型 方法名(参数)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>例如，</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericMethod</span> </span>&#123;	  <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;<br>    	System.out.println(mvp.getClass());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-function">MVP <span class="hljs-title">show2</span><span class="hljs-params">(MVP mvp)</span> </span>&#123;	<br>    	<span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        MyGenericMethod mm = <span class="hljs-keyword">new</span> MyGenericMethod();<br>        <span class="hljs-comment">// 演示看方法提示</span><br>        mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        mm.show(<span class="hljs-number">123</span>);<br>        mm.show(<span class="hljs-number">12.45</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;<br></code></pre></div></td></tr></table></figure>
<p>例如，</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span></span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImp2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyGenericInterface</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>       	 <span class="hljs-comment">// 省略...</span><br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getE</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyImp2&lt;String&gt;  my = <span class="hljs-keyword">new</span> MyImp2&lt;String&gt;();  <br>        my.add(<span class="hljs-string">&quot;aa&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list1);<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    getElement(list2);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></div></td></tr></table></figure>
<p>泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p>
<h3 id="通配符高级使用——受限泛型"><a href="#通配符高级使用——受限泛型" class="headerlink" title="通配符高级使用——受限泛型"></a>通配符高级使用——受限泛型</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Practical Adversarial Attacks Against Speaker Recognition Systems</title>
    <url>/2021/09/23/Practical%20Adversarial%20Attacks%20Against%20Speaker%20Recognition%20Systems/</url>
    <content><![CDATA[<blockquote>
<p>文章题目：Practical Adversarial Attacks Against Speaker Recognition Systems</p>
<p>来源：ACM HotMobile 2020</p>
<p>链接：<a href="https://dl.acm.org/doi/abs/10.1145/3376897.3377856">https://dl.acm.org/doi/abs/10.1145/3376897.3377856</a></p>
</blockquote>
<h2 id="文章概述"><a href="#文章概述" class="headerlink" title="文章概述"></a>文章概述</h2><p>对基于X-vector的multi-class speaker recognition system（其实就是一个闭集多分类模型，speaker identificaiton）进行adversarial example attacks，即对输入音频加入人类察觉不到的小扰动使得speaker recognition system分类出错。具体包括两种攻击类型：untargeted attack and targeted attack。并且加在generate adversarial example时加入了estimated RIR(room impulse response)，模拟在真实场景下的各种因素（multi-path effect, noise etc.）。在VCTK数据集上进行digital attack和practical attack，每种场景下都评估上述两种攻击类型的表现。98% digital untargeted attack success rate,  50% practical targeted attack success rate。</p>
<h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923161432.png" alt=""></p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="Room-impulse-Response-Estimation"><a href="#Room-impulse-Response-Estimation" class="headerlink" title="Room impulse Response Estimation"></a>Room impulse Response Estimation</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923161622.png" alt=""></p>
<p>其中，$<br>y\left( t \right)<br>$是麦克风记录音频样本，$<br>x\left( t \right)<br>$是扬声器发出的音频样本，$<br>K\left[  \right]<br>$ is the N-th order discrete-time Volterra kernel to represent a nonlinear memoryless system，$<br>h’\left( t \right)<br>$ is an impulse response characterizing linear distortions (i.e., delays and attenuations)，$<br>\bigotimes<br>$是卷积操作，$<br>n\left( t \right)<br>$是与输入音频无关的环境噪声。</p>
<p>实际情况下一般简化考虑为：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923162547.png" alt=""></p>
<p>其中$<br>h\left( t \right)<br>$为RIR(Room Iimpulse Response)，是一个能够综合表示线性和非线性的因素的脉冲响应。</p>
<p>文章通过preliminary experiment测量出不同场景下的estimated RIR，具体如下：</p>
<p>1.使用扬声器发射一个刺激信号$<br>x_e\left( t \right)<br>$，具体可表示如下：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923162931.png" alt=""></p>
<p>2.使用麦克风记录音频信号，通过卷积操作得到estimated RIR, $<br>h\left( t \right)<br>$，具体如下：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923163155.png" alt=""></p>
<p>其中$<br>f\left( t \right)<br>$由$<br>x_e\left( t \right)<br>$进行time-reversal得到</p>
<p>通过实验证明了这种preliminary experiment的有效性，在后续攻击评估中都使用了这种方法预先测量出estimated RIR</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923163413.png" alt=""></p>
<h3 id="Untargeted-Attack-Example"><a href="#Untargeted-Attack-Example" class="headerlink" title="Untargeted Attack Example"></a>Untargeted Attack Example</h3><p>untargeted attack即使得speaker recognition system分类错误就行，制造这种example只需对输入样本加上一个扰动$<br>\delta<br>$即可：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923210725.png" alt=""></p>
<p>由于是untargeted attack，因此扰动$<br>\delta<br>$可以直接利用DNN模型的局部线性特性，使用FGSM(fast gradient sign method)生成，即对每个输入样本计算（<code>一次计算生成</code>）：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923202031.png" alt=""></p>
<p>具体到本文攻击的x-vector多说话人分类模型，因此loss使用cross-entropy，adversarial example可表示为：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923165556.png" alt=""></p>
<p>对应的，在真实场景中进行attack的example，加入estiamted RIR即可：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923165651.png" alt=""></p>
<h3 id="Targeted-Attack-Example"><a href="#Targeted-Attack-Example" class="headerlink" title="Targeted Attack Example"></a>Targeted Attack Example</h3><p>由于是targeted attack，需要让speaker recognition system将adversarial example分类为攻击者指定的目标$<br>y_t<br>$。因此需要解决一个optimization problem：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923170230.png" alt=""></p>
<p>上式可简化为：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923170251.png" alt=""></p>
<p>因此需要对每个样本进行梯度下降（<code>迭代生成</code>）得到optimal $<br>\delta *<br>$，然后对原始样本加上扰动即可</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923201523.png" alt=""></p>
<p>类似的，如果要生成在真实场景下的adversarial example，考虑estimated RIR即可：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923201637.png" alt=""></p>
<h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2><h3 id="数据集和Baseline-Model"><a href="#数据集和Baseline-Model" class="headerlink" title="数据集和Baseline Model"></a>数据集和Baseline Model</h3><p>使用VCTK数据集，对x-vector多说话人分类speaker recognition systemt进行adversarial example attack evaluation</p>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><ul>
<li>Speaker Recognition Accuracy</li>
<li>Attack Success Rate</li>
<li>Distortion Metric：评估perturbation相对原始音频的幅值占比，越大代表扰动perturbation越明显，越容易被发觉</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="Evaluation-of-Digital-Attacks"><a href="#Evaluation-of-Digital-Attacks" class="headerlink" title="Evaluation of Digital Attacks"></a>Evaluation of Digital Attacks</h4><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923202445.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923202648.png" alt=""></p>
<h4 id="Evaluation-of-Practical-Attacks"><a href="#Evaluation-of-Practical-Attacks" class="headerlink" title="Evaluation of Practical Attacks"></a>Evaluation of Practical Attacks</h4><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923202719.png" alt=""></p>
<p>对于untargeted attack，由于various environmental interferences (e.g., multipath, ambient noises)，导致x-vector based speaker recognition mis-classified all samples. 因此attack success ratio是100%</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210923210811.png" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="white-box-setting"><a href="#white-box-setting" class="headerlink" title="white-box setting"></a>white-box setting</h3><p>has complete knowledge to the speaker recognition model，需要Practical Black-box Attack，比如现在商用的speaker recognition system(e.g. Microsoft Azure)是不公开model的</p>
<h4 id="可能的解决方案"><a href="#可能的解决方案" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h4><ol>
<li><p>gradient-free optimization algorithms (e.g., genetic algorithm) </p>
</li>
<li><p>training a substitute model.</p>
</li>
</ol>
<h3 id="estimated-RIR"><a href="#estimated-RIR" class="headerlink" title="estimated RIR:"></a>estimated RIR:</h3><p>通过preliminary experiment来estimating RIR，可能在某些室内场景中是不可行的或者在室外环境中是很难实现的</p>
<h4 id="可能的解决方案-1"><a href="#可能的解决方案-1" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h4><ol>
<li>room simulators to approximate the actual RIR </li>
<li>RIR augmentation techniques：direction-to-reverberant ratio (DRR)</li>
</ol>
<h3 id="Bypassing-Liveness-Detection"><a href="#Bypassing-Liveness-Detection" class="headerlink" title="Bypassing Liveness Detection"></a>Bypassing Liveness Detection</h3><p>防守方可以加入liveness detection即可抵抗本文的攻击方法</p>
<h4 id="可能的解决方案-2"><a href="#可能的解决方案-2" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h4><ol>
<li>设计一种audio-agnostic universal perturbation，与输入音频样本无关，当活体输入语音时，注入这种perturbation从而绕过liveness detection</li>
</ol>
<h3 id="文章的Practical-attack-evaluation"><a href="#文章的Practical-attack-evaluation" class="headerlink" title="文章的Practical attack evaluation"></a>文章的Practical attack evaluation</h3><p>由于文章中使用的Speaker recognition system是Kaldi Pre-trained，因此并不具备Robust ablilty to environmental interferences，因此得到的实验结果其实也是不可靠的。</p>
]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speaker Recognition</category>
        <category>Adversarial Example</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Speaker Recognition</tag>
        <tag>Adversarial Example</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Seeing is Not Believing：Camouflage Attacks on Image Scaling Algorithms</title>
    <url>/2020/09/13/Seeing%20is%20Not%20Believing%EF%BC%9ACamouflage%20Attacks%20on%20Image%20Scaling%20Algorithms/</url>
    <content><![CDATA[<p>论文题目：Seeing is Not Believing：Camouflage Attacks on Image Scaling Algorithms</p>
<p>来源：28th USENIX Security Symposium 2019</p>
<p>链接：<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/xiao">https://www.usenix.org/conference/usenixsecurity19/presentation/xiao</a></p>
<h2 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h2><p>作者发现了<strong>一种在图像处理过程中潜藏的安全风险——图像维度变换攻击。</strong>攻击者可以通过构造攻击图片，致使输入图像在经过尺寸维度变化后发生明显的内容语义改变，造成人与机器的认知差异，从而达到欺骗、逃逸检测的攻击效果。与针对深度学习模型的对抗样本不同，该攻击方法不局限于特定模型，因为其是针对基于深度学习的计算机视觉应用的必要功能：图像伸缩函数，这一步是位于深度学习模型进行训练/预测之前的，因此该攻击影响范围更大。</p>
<p>为验证攻击方法的有效性，作者对基于Caffe、Tensorflow、Torch等流行深度框架搭建的多个AI视觉应用成功实施了欺骗攻击。此外，作者还考察了该风险对商业视觉服务的影响。实验结果证明，即使是黑盒系统，仍然能够通过测试策略获取被攻击对象的算法和相关参数，并发动图像维度变换攻击。经测试，在国内主流云AI服务和微软Azure等国际厂商提供的机器视觉服务中，均发现了类似风险。此外作者还通过实验发现有些主流浏览器，比如Firefox、Microsoft Edge(Old)也存在该漏洞，而Chrome并没有这问题。</p>
<h3 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h3><p><img src="https://pic.downk.cc/item/5f5c702b160a154a6717ad22.jpg" alt=""></p>
<h3 id="创新点："><a href="#创新点：" class="headerlink" title="创新点："></a>创新点：</h3><p>①本文揭示了计算机视觉应用中图像缩放过程中存在的安全隐患。我们对目前流行的深度学习框架中常用的图像缩放算法进行了验证和验证，结果表明，基于DL框架的图像应用几乎都存在安全风险。</p>
<p>②本文将缩放攻击形式化为一个约束优化问题，并给出了相应的实现方法，实现了伪装图像的自动高效生成。</p>
<p>③此外，作者证明了所提出的攻击对云视觉服务仍然有效，即使这些云服务的图像缩放算法的实现细节和参数对用户是隐藏的（但是可以通过相关测试获取这些云服务厂商所采用的图像缩放算法的相关参数）。</p>
<p>④为了消除伸缩攻击带来的威胁，作者从攻击预防和检测两个方面提出了几种潜在的防御策略，</p>
<h3 id="可能的攻击应用："><a href="#可能的攻击应用：" class="headerlink" title="可能的攻击应用："></a>可能的攻击应用：</h3><p>①数据中毒：通过向公开数据集（如ImageNet）中注入经过缩放攻击篡改过后的图像，比如放入一张看上去是羊的图片，并且标签也是羊，但通过缩放后实际是狼，通过这样让数据中毒攻击更加隐蔽，使得数据集使用者无法发现这种数据污染。</p>
<p>②逃避内容审查。内容审查是最广泛使用的计算机视觉应用程序之一。许多供应商提供内容过滤服务，以防止攻击性内容。攻击者可能会利用缩放攻击来避开这些内容，传播不适当的图片，这可能会在线社区引发严重问题。例如，假设攻击者想在iPhone XS上向用户发布非法药物广告。攻击者可以使用缩放攻击来创建一种伪装效果，使iPhone XS浏览器上的缩放结果是预期的药物图像，而原始大小的图像包含良性内容。</p>
<p>③利用显示器之间的不一致进行欺诈。攻击者可以使用缩放攻击创建具有欺骗性的数字合同。攻击者可以创建一个包含扫描合同的图像文档，但当缩放到不同的比例时呈现不同的内容。然后，攻击者可以让双方共享同一文档。如果它们使用不同的浏览器，那么显示的内容也会不同。这种不一致可能导致潜在财务欺诈。</p>
<h3 id="防范与检测："><a href="#防范与检测：" class="headerlink" title="防范与检测："></a>防范与检测：</h3><h4 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h4><p>①过滤掉与DL模型输入不符合的输入（但是这种方法在实际中是很不人性化的，用户的输入都是随机的）</p>
<p>②在进行尺寸缩放之前，进行一些其他预处理，比如上述所说的过滤，裁剪等</p>
<h4 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h4><p>检测在缩放过程中输入特征的变化，如颜色直方图和颜色散射分布。如果是没有被篡改过的图片，其输入和缩放后的输出，在这两个图上的分布是基本一致的。具体如下图</p>
<p><img src="https://pic.downk.cc/item/5f5cacc0160a154a672726ab.jpg" alt=""></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>对于黑盒攻击（也就是实战中的大部分情况），即对于那些基于云服务的CV应用来说，目标缩放算法和输入尺寸都是不知道的，需要进行构造一系列的探测序列图像来推测具体的缩放算法和输入尺寸。（尽管本文中提出了推测具体缩放算法和输入尺寸的步骤）这会导致攻击成功率下降，和不确定性增大，且会增大攻击成本。而且对于这种CV应用，可能对输入的图片预处理不单单只是图像尺寸缩放，还可能有图像裁切、过滤、仿射变换、颜色变换等预处理操作。如果这些步骤是先于图像尺寸缩放的话，那就很可能严重降低图像缩放攻击的成功性。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>该攻击算法本质上是强行计算出一对系数矩阵，使得输入图像乘以这对系数矩阵的结果，通过缩放算法后能输出攻击者想要的目标图像。其实是对缩放算法的一个逆运算。这种攻击的原理不难，却能广泛应用在各种图像处理应用上，包括本地CV应用、云服务CV API甚至是当前主流的Web浏览器上，但凡可能用到图像缩放函数的应用都可能遭受此攻击。尽管该攻击需要了解对缩放函数和输入尺寸的具体细节才能有高效的攻击成功率，且尽量不要有其他图像预处理步骤来干扰，也就是说这种攻击可能在现实环境中的效率可能不会太高，但对于思考CV模型的安全，减少AI应用的安全隐患，特别是对于图像应用，其整体的pipeline是否设置规范，有着很大的启发意义。</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Who is Real Bob? Adversarial Attacks on Speaker Recognition Systems</title>
    <url>/2021/09/24/Who-is-Real-Bob-Adversarial-Attacks-on-Speaker-Recognition-Systems/</url>
    <content><![CDATA[<blockquote>
<p>文章题目：Who is Real Bob? Adversarial Attacks on Speaker Recognition Systems</p>
<p>来源：2021 IEEE Symposium on Security and Privacy (SP)</p>
<p>链接：<a href="https://ieeexplore.ieee.org/document/9519486/">https://ieeexplore.ieee.org/document/9519486/</a></p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>the impacts of adversarial attack in the practical black-box setting are still open</li>
</ul>
<h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><ul>
<li>C1：Crafting adversarial samples as less imperceptible as possible in the black-box setting.</li>
<li>C2：Making the attack practical, namely, adversarial samples are effective on an unknown SRS, even when playing over the air in the physical world.</li>
</ul>
<h3 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h3><ul>
<li>To our knowledge, this is the first study of targeted adversarial attacks on SRSs in the black-box setting. Our attack is launched by not only using gradient estimation based methods, but also incorporating the score threshold into the adversarial sample generation. The proposed algorithm to estimate the score threshold is unique in SRSs</li>
<li>Our black-box attack addresses not only the speaker recognition tasks considered by existing white-box attacks but also the more general task, open-set identification, which has not been considered by previous adversarial attacks.</li>
<li>Our attack is demonstrated to be effective on the popular open-source systems and commercial system Talentedsoft, transferable and practical on the popular open-source systems and the open-set identification task of Microsoft Azure even when playing over the air in the physical world.</li>
<li>Our attack is robust against four potential defense methods which are reported very promising in speech recognition domain. Our study reveals the security implications of the adversarial attack on SRSs, which calls for more robust SRSs and more effective domain-specific defense methods.</li>
</ul>
<h2 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h2><h3 id="Attack-scenarios"><a href="#Attack-scenarios" class="headerlink" title="Attack scenarios"></a>Attack scenarios</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925155722.png" alt=""></p>
<h3 id="Attack-hypothesis"><a href="#Attack-hypothesis" class="headerlink" title="Attack hypothesis"></a>Attack hypothesis</h3><ul>
<li>adversary has some voices of the target speakers to build a surrogate model, while these voices are not necessary the enrollment voices。即对于targeted attack，假设adversary能够拥有desired target speaker的voice，从而能够query black-box SRS得到对应的score和decision</li>
</ul>
<h2 id="System-design"><a href="#System-design" class="headerlink" title="System design"></a>System design</h2><h3 id="FAKEBOB-overview"><a href="#FAKEBOB-overview" class="headerlink" title="FAKEBOB overview"></a>FAKEBOB overview</h3><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925163435.png" alt=""></p>
<p>为了生成adversarial example，也是将其定义为一个最优化问题(optimization problem)，即最小化一个自定义的loss</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925221043.png" alt=""></p>
<p>$f\left(  \right)$即为loss function，$x$是source voice。所有input先会经过normalization到[-1,1]，然后加上扰动（perturbation）$\delta$，得到adversarial example，最后经过一个逆变换过程将数据恢复到原始scale。</p>
<p>该loss会根据不同的targets SRS，略作修改，总体思想是使得source voice加上扰动（perturbation）$\delta$后（即成为adversarial voice）与victim voice越来越像，并且设置一个参数$\epsilon$来限制$\delta$的强弱。</p>
<h3 id="Attack-on-OSI"><a href="#Attack-on-OSI" class="headerlink" title="Attack on OSI"></a>Attack on OSI</h3><p>OSI作为本文主要攻击目标，因为它目前商用SRS最为重要的应用场景</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224136.png" alt=""></p>
<p><strong>targeted attack loss：</strong></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222153.png" alt=""></p>
<p><strong>untargeted attack loss：</strong></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222203.png" alt=""></p>
<p>该文主要攻击target是OSI SRS，且是black-box setting，所以无法得知SRS具体的threshold，因此本文提出了一种threshold estimation算法，如下图：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222309.png" alt=""></p>
<p><code>该算法使得estiamted threshold not less than real threshold（not seen to adversary）</code></p>
<p>文章也通过实验评估了该threshold estimation算法的有效性</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210926202719.png" alt=""></p>
<p>同样地，由于是black-box setting无法得知SRS具体的loss function和内部parameters weights，也就无法使用gradient-based mehtod（直接）来生成adversarial example。为了解决这一问题，使用NES算法(Natural Evolution Strategy)来得到estiamted gradient，然后使用BIM（Basic Iterative Method）进行estimated gradient descent来得到最优的adversarial example。</p>
<p>BIM公式如下：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222632.png" alt=""></p>
<p>其中$\acute{x}_0=x$，clip函数是为了对扰动$\delta$加以限制，具体为：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222740.png" alt=""></p>
<p>NES生成estimated gradient公式如下：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925222905.png" alt=""></p>
<p>$u_j$是每轮iteration随机生成的Gaussian noises，是一个向量$\left( u_1,…,u_m \right)$，服从高斯分布。然后将这个向量的每个元素分别加到$\acute{x}_{i-1}$得到$\acute{x}_{i-1}^{1},…,\acute{x}_{i-1}^{\boldsymbol{m}}\ \boldsymbol{where\ }\acute{x}_{i-1}^{j}=\acute{x}_{i-1}+\sigma \times u_j<br>$</p>
<p>而且$u_j=-u_{\boldsymbol{m}+1-\boldsymbol{j}}\ \boldsymbol{for\ j}=1,…\frac{\boldsymbol{m}}{2}$</p>
<p>其中$m=50$，$\sigma =1e−3$，均为超参数，本文已经设为定值</p>
<h3 id="Attack-on-CSI"><a href="#Attack-on-CSI" class="headerlink" title="Attack on CSI"></a>Attack on CSI</h3><p>CSI没有threshold设定，因此loss相对简单，具体如下：</p>
<p><strong>targeted attack loss：</strong></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925223753.png" alt=""></p>
<p><strong>untargeted attack loss：</strong></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925223808.png" alt=""></p>
<h3 id="Attack-on-SV"><a href="#Attack-on-SV" class="headerlink" title="Attack on SV"></a>Attack on SV</h3><p>由于SV是一个一对一问题，因此targeted attack和untargeted attack的目标是一样的，具体Loss：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925223955.png" alt=""></p>
<p>由于只有一个enrolled speaker，因此在生成estimated threshold时候，需要换成：</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224105.png" alt=""></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224309.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224326.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224344.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/1632581045.jpg" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224501.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20210925224509.png" alt=""></p>
<p>本文做了大量详尽的evaluation，详见原文appendix</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>实现practical attack仅仅是加强了perturbation strength，而不是建立noise model，原文给出的原因是害怕产生environment and device-dependent。这会导致攻击的不可感知性（imperceptibility）大幅下降，特别是进行over-the-air attack时<ol>
<li>room simulators to approximate the actual RIR</li>
<li>RIR augmentation techniques：direction-to-reverberant ratio (DRR)</li>
</ol>
</li>
<li>文中提出的方法只适用于score和decision都能得到的black-box SRS，如果只能得到decision，原文中只能使用transfer attack</li>
<li>无法抵抗liveness detection，即无法做到实时生成adversarial example（无法在live user说话时，实时生成相应的perturbation）</li>
<li>因为定义的loss optimization problem很难解，使得迭代生成adversarial example时间较长（基本都在10min以上），感觉实际应用场景很少</li>
</ul>
]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speaker Recognition</category>
        <category>Adversarial Example</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Speaker Recognition</tag>
        <tag>Adversarial Example</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2020/12/25/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Collection单列集合"><a href="#Collection单列集合" class="headerlink" title="Collection单列集合"></a>Collection单列集合</h1><p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20201231130452.png" alt=""></p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/image-20201231130515656.png" alt=""></p>
<center><h6>Java集合综述<br>图片来源：https://segmentfault.com/a/1190000019946237【如有侵权，必删】</h6></center>

<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/Java_Collections_Framework_Overview.png" alt=""></p>
<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<blockquote>
<p>集合和数组的区别</p>
</blockquote>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型，也可以存储引用数据类型。集合存储的都是引用数据类型（对象），而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，现主要学习<code>Collection</code>单列集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20201225173326.png" alt=""><br>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。其中具体每个类的特性如下图所示</p>
<p><img src="https://rershall123.oss-cn-hangzhou.aliyuncs.com/img/20201225173037.png" alt=""></p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最为共性的内容。</p>
<h2 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a>Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1Collection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建集合对象 </span><br>    	<span class="hljs-comment">// 使用多态形式</span><br>    	Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    	<span class="hljs-comment">// 使用方法</span><br>    	<span class="hljs-comment">// 添加功能  boolean  add(String s)</span><br>    	coll.add(<span class="hljs-string">&quot;小李广&quot;</span>);<br>    	coll.add(<span class="hljs-string">&quot;扫地僧&quot;</span>);<br>    	coll.add(<span class="hljs-string">&quot;石破天&quot;</span>);<br>    	System.out.println(coll);<br><br>    	<span class="hljs-comment">// boolean contains(E e) 判断o是否在集合中存在</span><br>    	System.out.println(<span class="hljs-string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="hljs-string">&quot;扫地僧&quot;</span>));<br><br>    	<span class="hljs-comment">//boolean remove(E e) 删除在集合中的o元素</span><br>    	System.out.println(<span class="hljs-string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="hljs-string">&quot;石破天&quot;</span>));<br>    	System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+coll);<br>    	<br>    	<span class="hljs-comment">// size() 集合中有几个元素</span><br>		System.out.println(<span class="hljs-string">&quot;集合中有&quot;</span>+coll.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br><br>		<span class="hljs-comment">// Object[] toArray()转换成一个Object数组</span><br>    	Object[] objects = coll.toArray();<br>    	<span class="hljs-comment">// 遍历数组</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>			System.out.println(objects[i]);<br>		&#125;<br><br>		<span class="hljs-comment">// void  clear() 清空集合</span><br>		coll.clear();<br>		System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+coll);<br>		<span class="hljs-comment">// boolean  isEmpty()  判断是否为空</span><br>		System.out.println(coll.isEmpty());  	<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用多态方式 创建对象</span><br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        <span class="hljs-comment">// 添加元素到集合</span><br>        coll.add(<span class="hljs-string">&quot;串串星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;吐槽星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;汪星人&quot;</span>);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-comment">//  泛型指的是 迭代出 元素的数据类型</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//判断是否有迭代元素</span><br>            String s = it.next();<span class="hljs-comment">//获取迭代出的元素</span><br>            System.out.println(s);<br>        &#125;<br>  	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  	<span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它用于遍历Collection和数组。通常只进行遍历元素，不能在遍历的过程中对集合元素进行增删操作。</p>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBForDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">87</span>&#125;;<br>       	<span class="hljs-comment">//使用增强for遍历数组</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr)&#123;<span class="hljs-comment">//a代表数组中的每个元素</span><br>			System.out.println(a);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBFor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br>    	Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    	coll.add(<span class="hljs-string">&quot;小河神&quot;</span>);<br>    	coll.add(<span class="hljs-string">&quot;老河神&quot;</span>);<br>    	coll.add(<span class="hljs-string">&quot;神婆&quot;</span>);<br>    	<span class="hljs-comment">//使用增强for遍历</span><br>    	<span class="hljs-keyword">for</span>(String s :coll)&#123;<span class="hljs-comment">//接收变量s代表 代表被遍历到的集合元素</span><br>    		System.out.println(s);<br>    	&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：Towards Query-Efficient Adversarial Attacks Against Automatic Speech Recognition Systems</title>
    <url>/2021/10/08/Towards-Query-Efficient-Adversarial-Attacks-Against-Automatic-Speech-Recognition-Systems/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>论文学习</category>
        <category>Speech Recognition</category>
        <category>Adversarial Example</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
        <tag>Speech Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>论文学习：On Training Robust PDF Malware Classifiers</title>
    <url>/2020/09/05/On%20Training%20Robust%20PDF%20Malware%20Classifiers/</url>
    <content><![CDATA[<p>论文题目：On Training Robust PDF Malware Classifiers</p>
<p>来源：29th USENIX Security Symposium 2020</p>
<p>链接：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/chen-yizheng">https://www.usenix.org/conference/usenixsecurity20/presentation/chen-yizheng</a></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>参考<a href="https://blog.csdn.net/Shall_ByeBye/article/details/106883218">https://blog.csdn.net/Shall_ByeBye/article/details/106883218</a></p>
<h2 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h2><p>指出目前有能够轻易逃避恶意PDF文件的检测器的方法，且目前的模型都是一味的追求高检测准确率和低误判率。本文通过加入鲁棒性属性，训练出一种强鲁棒性的恶意PDF检测模型，相比于一般检测模型具有更强的鲁棒性，面对一般的逃逸攻击具有更好的检测效果。</p>
<p>本篇工作针对PDF恶意软件提出了新的鲁棒训练方法。本篇工作采用Verifiably Robust Training，<strong>利用有效PDF必须能被解析为树结构的特点</strong>，提出了一种针对PDF树结构的新距离指标，并借助这种距离指标指定了两类鲁棒属性，<strong>子树插入和删除</strong>。只要攻击者符合鲁棒属性，再强的攻击者也无法产生可逃避分类器检测的变种。比如，指定鲁棒属性为插入1棵子树，任何通过插入1棵子树生成的PDF恶意软件变种都无法逃避检测。</p>
<h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><p>①过往研究表明，训练恶意软件分类器时，若训练集中有对抗性的样本，训练出来的模型的FP率会很高。</p>
<p>解决：提出新的指标来衡量PDF文件结构树，从而降低模型的FP率。（好扯）</p>
<p>②传统流行的用于恶意PDF检测的算法并不适用于训练一个具有强鲁棒性的分类器，例如随机森林。</p>
<p>解决：使用神经网络来训练一个强鲁棒性的分类器。（强行）</p>
<p>③为了评估本文提出的模型的鲁棒性，使用7种攻击分别对12个基线模型进行攻击测试。</p>
<h3 id="创新点："><a href="#创新点：" class="headerlink" title="创新点："></a>创新点：</h3><p>①：尽管现在在机器学习领域有很多性能指标去衡量模型的好坏，但没有一个适合用于评估一个专门检测自适应对抗攻击的模型的鲁棒性。专门提出一种新的指标去衡量PDF文件以降低模型的FPR</p>
<p>作者发现，所有能保留恶意功能的PDF恶意软件变种，都必须满足正确的PDF语法，即可以被解析为树结构。为了能够系统，高效的生成变种，<strong>攻击者必然使用子树插入和子树删除操作恶意软件生成变种。只要分类器对这两种操作有鲁棒性，那么它对逃避攻击也就有了鲁棒性。</strong><br>作者据此提出了<strong>子树距离作为距离指标</strong>：两个PDF软件的子树距离，即它们根节点下不同子树的数量。无论在x的根节点下插入1棵怎样的子树，x与生成的变种x˜的子树距离都是1。这样可以更好的限制鲁棒区域，降低FPR.<br>借助子树距离的限制，作者指定了子树距离为1时，子树插入和子树删除两种基础鲁棒属性。</p>
<p><strong>鲁棒属性具体是</strong>：对恶意软件进行任意子树插入（删除）操作生成的子树距离为1的变种，分类器不会将其分类为良性。这些属性都可以推广到子树距离为N的情况。**</p>
]]></content>
      <categories>
        <category>论文学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
</search>
